#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
%% use full paper
\usepackage[margin=2cm]{geometry}

%% multicols
\usepackage{multicol}

%% no automated date after title 
\date{}

%% compact spacing
\usepackage[compact]{titlesec}
\usepackage{enumitem}
\setlist{nolistsep}

%% table formatting
\usepackage{graphicx} 

%% colors
\usepackage{xcolor, amsmath}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\definecolor{amaranth}{rgb}{0.9, 0.17, 0.31}
\DontPrintSemicolon

% Define pseudocode formatting
\SetAlgoVlined
\renewcommand{\KwSty}[1]{\textnormal{\textcolor{amaranth!90!black}{\bfseries #1}}\unskip}
\renewcommand{\ArgSty}[1]{\textnormal{\ttfamily #1}\unskip}
\SetKwComment{Comment}{\color{green!80!black!190}// }{}
\renewcommand{\CommentSty}[1]{\textnormal{\ttfamily\color{green!80!black!190}#1}\unskip}
\newcommand{\assign}{\leftarrow}
\newcommand{\var}{\texttt}
\newcommand{\FuncCall}[2]{\texttt{\bfseries #1(#2)}}
\SetKwProg{Function}{function}{}{}
\SetKw{Continue}{continue}
\SetKw{KwTo}{to}
\SetKw{KwInn}{in}
\SetKw{KwAnd}{and}
\SetKw{KwOr}{or}
\SetKw{KwForall}{forall}
\renewcommand{\ProgSty}[1]{\texttt{\bfseries #1}}
\SetAlFnt{\small}
\usepackage{setspace}
%\AtBeginEnvironment{algorithm}{\setstretch{0.75}}

% Pseudocode title
\SetAlgorithmName{Pseudocode}{algorithmautorefname}
%\usepackage{algorithm}
%\usepackage[noend]{algpseudocode}
%\floatname{algorithm}{Pseudocode}

% text highlight
\newcommand{\hyellow}[1]{\colorbox{yellow!20}{#1}}
\newcommand{\horange}[1]{\colorbox{orange!20}{#1}}
\newcommand{\hgreen}[1]{\colorbox{green!20}{#1}}
\newcommand{\hred}[1]{\colorbox{red!30}{#1}}

% titlespace
\usepackage{titling}

% no ugly indent
\setlength\parindent{0pt}

% algorithm highlight
\usepackage{tikz}
\usetikzlibrary{fit,calc}
\newcommand{\boxi}[2]{
	\tikz[remember picture,overlay] \node (A) {};\ignorespaces
	\tikz[remember picture,overlay]{\node[yshift=3pt,fill=#1,opacity=.25,fit={($(A)+(0,0.15\baselineskip)$)($(A)+(.946\linewidth,-{#2}\baselineskip - 0.25\baselineskip)$)}] {};}\ignorespaces
}
\newcommand{\boxit}[2]{
	\tikz[remember picture,overlay] \node (A) {};\ignorespaces
	\tikz[remember picture,overlay]{\node[yshift=3pt,fill=#1,opacity=.25,fit={($(A)+(0,0.15\baselineskip)$)($(A)+(.915\linewidth,-{#2}\baselineskip - 0.25\baselineskip)$)}] {};}\ignorespaces
}
\newcommand{\boxitt}[2]{
	\tikz[remember picture,overlay] \node (A) {};\ignorespaces
	\tikz[remember picture,overlay]{\node[yshift=3pt,fill=#1,opacity=.25,fit={($(A)+(0,0.15\baselineskip)$)($(A)+(.876\linewidth,-{#2}\baselineskip - 0.25\baselineskip)$)}] {};}\ignorespaces
}
\newcommand{\boxittt}[2]{
	\tikz[remember picture,overlay] \node (A) {};\ignorespaces
	\tikz[remember picture,overlay]{\node[yshift=3pt,fill=#1,opacity=.25,fit={($(A)+(0,0.15\baselineskip)$)($(A)+(.837\linewidth,-{#2}\baselineskip - 0.25\baselineskip)$)}] {};}\ignorespaces
}

\colorlet{green}{green!30}
\colorlet{yellow}{yellow!40}
\colorlet{red}{red!30}

% algorithm comments on the right side
\usepackage{algpseudocode}
%\renewcommand{\algorithmiccomment}[1]{\bgroup\hfill\tiny//~#1\egroup}
\end_preamble
\use_default_options true
\begin_modules
algolyx
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=trbl,backgroundcolor={\color{lightgray}},flexiblecolumns=true,basicstyle={\small\ttfamily},breaklines=true,keywordstyle={\color{blue}\bfseries},language=Java,sensitive=true,emph={[1]{critical_section}},emphstyle={[1]\color{red}},emph={[2]{atomic,Condition}},emphstyle={[2]\color{blue}},rulesepcolor={\color{gray}},emph={[3]{acquire(mutex),release(mutex),signal(mutex)}},emphstyle={[3]\color{magenta}},showstringspaces=false,stringstyle={\color{purple}},commentstyle={\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small},morecomment={[l][\color{Blue}]{...}},tabsize=4,lineskip={-1.5pt}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset ERT
status open

\begin_layout Plain Layout

C
\backslash
texttt{++}
\end_layout

\end_inset

 DP-GBDT Side-channel Analysis
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Secrecy
\end_layout

\begin_layout Subsection
Dataset and parameters
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secret
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
content of X
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X_cols_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X_rows_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
content of y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y_rows_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secret
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nb_trees
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
learning_rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
privacy_budget
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
task
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max_depth
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
min_samples_split
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
balance_partition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gradient_filtering
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
leaf_clipping
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scale_y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
use_decay
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
l2_threshold
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
l2_lambda
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cat_idx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_idx
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
inferrable from those
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secret
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nb_samples per tree
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
While building a single tree
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
entity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
secret
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X_subset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X_subset_cols_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\times$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X_subset_rows_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y_subset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
y_subset_rows_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gradients
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gradients_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\checkmark$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Subsection
DP imperfections of the algorithm
\end_layout

\begin_layout Itemize

\family typewriter
init_score
\family default
, (=mean in regression, =most common feature in classification) leaks informatio
n about which feature values are in the dataset.
 Would need to add noise.
\end_layout

\begin_layout Itemize

\family typewriter
compute_gain
\family default
 is done on the real data points.
 This was not adressed by the DPBoost paper.
 Would also need to add noise there.
\end_layout

\begin_layout Itemize
GDF is also problematic.
 changing one data point could have an impact on 2 trees.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section

\family typewriter
main
\end_layout

\begin_layout Standard
No data dependent operations are done, therefore no side channel leakage.
 Securely getting the model parameters and dataset into and the resulting
 model out of the enclave is not among the challenges of this thesis.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{main}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function {main()}{
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{get parameters and dataset}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{parameters} = 
\backslash
texttt{get
\backslash
_params()}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{dataset} = 
\backslash
texttt{get
\backslash
_dataset()}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{create 5 train/test splits for cross validation}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{cv
\backslash
_splits} = 
\backslash
texttt{create
\backslash
_cross
\backslash
_val
\backslash
_inputs(dataset, 5)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{do cross validation}
\end_layout

\begin_layout Plain Layout

	
\backslash
For {split 
\backslash
KwInn cv
\backslash
_splits} {
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{ensemble} = 
\backslash
texttt{DPEnsemble(parameters)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		$
\backslash
emph{
\backslash
var{ensemble.train(split.train)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{predict using the test set}
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{y
\backslash
_pred} = 
\backslash
emph{
\backslash
var{ensemble.predict(split.test.X)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{compute score}
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{score} = 
\backslash
var{compute
\backslash
_score(split.test.y, y
\backslash
_pred)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section

\family typewriter
class DPTree
\end_layout

\begin_layout Subsection
Methods
\end_layout

\begin_layout Subsubsection

\family typewriter
fit
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/fit/class_d_p_tree_a82b9507f4f5d056b98f40871b304f943_icgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Call graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/fit/class_d_p_tree_a82b9507f4f5d056b98f40871b304f943_cgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
dataset, leaves
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
params.*
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{DPTree::fit}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function {fit()}{
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{all samples are live at the start}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{live
\backslash
_samples} = 
\backslash
texttt{[1,2,3,...,dataset.length]}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{build tree}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{this
\backslash
ensuremath{
\backslash
rightarrow}root
\backslash
_node} = 
\backslash
emph{
\backslash
texttt{make
\backslash
_tree
\backslash
_dfs(live
\backslash
_samples, 0)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{leaf
\backslash
_clipping} 
\backslash
boxit{green}{3.7}
\end_layout

\begin_layout Plain Layout

	
\backslash
If (
\backslash
Comment{params}) {params.leaf
\backslash
_clipping 
\backslash
KwOr !params.gradient
\backslash
_filtering} {
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{threshold} = 
\backslash
texttt{params.l2}
\backslash
ensuremath{*(1-
\backslash
eta)^{
\backslash
texttt{tree
\backslash
_index}}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
boxitt{red}{1.2}
\end_layout

\begin_layout Plain Layout

		
\backslash
For(
\backslash
Comment{number of leaves, which nodes are leaves}){leaf 
\backslash
KwInn this
\backslash
ensuremath{
\backslash
rightarrow}leaves} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{leaf.prediction} = 
\backslash
texttt{clamp(leaf.prediction, -threshold, threshold)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{add laplace noise to leaf values}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{privacy
\backslash
_budget
\backslash
_for
\backslash
_leaf
\backslash
_nodes} = 
\backslash
frac{
\backslash
texttt{tree
\backslash
_privacy
\backslash
_budget}} {2}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{laplace
\backslash
_scale} = 
\backslash
frac{
\backslash
var{params.
\backslash
ensuremath{
\backslash
Delta}v}}{
\backslash
texttt{privacy
\backslash
_budget
\backslash
_for
\backslash
_leaf
\backslash
_nodes}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
emph{
\backslash
var{add
\backslash
_laplacian
\backslash
_noise(laplace
\backslash
_scale)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
make_tree_dfs
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/make_tree_DFS/class_d_p_tree_a07314c44bb7b7ca37c735b70de3ccb9e_icgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Call graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/make_tree_DFS/class_d_p_tree_a07314c44bb7b7ca37c735b70de3ccb9e_cgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Arguments / variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
dataset, X_transposed, live_samples, gradients
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
params.min_samples_split, params.max_depth, curr_depth
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{DPTree::make
\backslash
_tree
\backslash
_dfs}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  
\backslash
boxi{red}{0}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function (
\backslash
Comment{size of 
\backslash
texttt{live
\backslash
_samples}}) {make
\backslash
_tree
\backslash
_dfs(live
\backslash
_samples, curr
\backslash
_depth)}{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{max depth reached or not enough samples -> leaf node} 
\backslash
boxit{red}{2}
\end_layout

\begin_layout Plain Layout

    
\backslash
If{curr
\backslash
_depth == params.max
\backslash
_depth 
\backslash
KwOr len(live
\backslash
_samples) < params.min
\backslash
_samples
\backslash
_split}{
\end_layout

\begin_layout Plain Layout

			$
\backslash
texttt{TreeNode *leaf = 
\backslash
emph{make
\backslash
_leaf
\backslash
_node(curr
\backslash
_depth, live
\backslash
_samples)}}$ 
\backslash
Comment{both branch conditions}
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			
\backslash
Return{$
\backslash
texttt{leaf}$}
\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{find best split}
\end_layout

\begin_layout Plain Layout

	$
\backslash
texttt{TreeNode *node = 
\backslash
emph{find
\backslash
_best
\backslash
_split(X, gradients, live
\backslash
_samples, curr
\backslash
_depth)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{no split found} 
\backslash
boxit{red}{1}
\end_layout

\begin_layout Plain Layout

    
\backslash
If (
\backslash
Comment{number of leaves}) {node.is
\backslash
_leaf }{
\end_layout

\begin_layout Plain Layout

		
\backslash
Return{$
\backslash
texttt{node}$}
\backslash

\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{prepare the new live samples to continue recursion} 
\backslash
boxit{yellow}{0}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{lhs,rhs} = 
\backslash
texttt{
\backslash
emph{samples
\backslash
_left
\backslash
_right
\backslash
_partition(X, node.feature
\backslash
_index, node.feature
\backslash
_value)}}$ 
\backslash
Comment{sizes}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{red}{4.5}
\end_layout

\begin_layout Plain Layout

	
\backslash
For (
\backslash
Comment{size of 
\backslash
texttt{live
\backslash
_samples}}) {sample 
\backslash
KwInn live
\backslash
_samples} {
\end_layout

\begin_layout Plain Layout

		
\backslash
boxitt{red}{3}
\end_layout

\begin_layout Plain Layout

		
\backslash
eIf (
\backslash
Comment{which samples go left/right}) {lhs.contains(sample)} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
texttt{lhs
\backslash
_live
\backslash
_samples.insert(sample)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
texttt{rhs
\backslash
_live
\backslash
_samples.insert(sample)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{recurse}
\end_layout

\begin_layout Plain Layout

	$
\backslash
texttt{node
\backslash
ensuremath{
\backslash
rightarrow}left = make
\backslash
_tree
\backslash
_dfs(lhs
\backslash
_live
\backslash
_samples, curr
\backslash
_depth+1)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
texttt{node
\backslash
ensuremath{
\backslash
rightarrow}right = make
\backslash
_tree
\backslash
_dfs(rhs
\backslash
_live
\backslash
_samples, curr
\backslash
_depth+1)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
Return{$
\backslash
texttt{node}$}
\backslash

\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Recursion leakage
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hred{
\end_layout

\end_inset

number of splits in the tree
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hred{
\end_layout

\end_inset

number of splits/leaves observable by watching memory allocations
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
exponential_mechanism
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/exponential_mechanism/class_d_p_tree_a7ce368c3888736d660dcf09587df4512_icgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Arguments / variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
candidates
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
-
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{DPTree::exponential
\backslash
_mechanism}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxi{red}{0}
\end_layout

\begin_layout Plain Layout

	
\backslash
Function (
\backslash
Comment{number of candidates}) {exponential
\backslash
_mechanism(candidates)}{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{if no split with positive gain, return, node will become a leaf}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{red}{1.2}
\end_layout

\begin_layout Plain Layout

    
\backslash
If (
\backslash
Comment{no good split exists, leaf creation}){cand.gain <= 0 
\backslash
KwForall cand 
\backslash
KwInn candidates} {  
\end_layout

\begin_layout Plain Layout

		$
\backslash
Return 
\backslash
var{-1}$
\backslash
;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{calculate probabilities from the gains}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{red}{6.8}
\end_layout

\begin_layout Plain Layout

	
\backslash
For(
\backslash
Comment{number of candidates}){candidate 
\backslash
KwInn candidates} {
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{gains.append(candidate.gain)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		
\backslash
boxitt{red}{4.5}
\end_layout

\begin_layout Plain Layout

		
\backslash
eIf (
\backslash
Comment{number of candidates with viable splits}) {candidate.gain <= 0} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{probabilities.append(0)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{lse} = 
\backslash
ensuremath{
\backslash
log
\backslash
sum_{i}
\backslash
exp(
\backslash
texttt{gains}_{i})}$
\backslash
;
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{probabilities.append(
\backslash
ensuremath{
\backslash
exp ({
\backslash
texttt{candidate.gain} - 
\backslash
var{lse}})})}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{create a cumulative distribution from the probabilities, its values
 add up to 1}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{partials} = 
\backslash
texttt{std::partial
\backslash
_sum(probabilities)}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{choose random value in [0,1]}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{rand
\backslash
_val} = 
\backslash
texttt{std::rand()}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{return the corresponding split}
\end_layout

\begin_layout Plain Layout

	
\backslash
For {i = 0 
\backslash
KwTo i = partials.size() - 1} {
\end_layout

\begin_layout Plain Layout

		
\backslash
If {partials[i] >= rand
\backslash
_val} {
\end_layout

\begin_layout Plain Layout

			
\backslash
Return $
\backslash
var{i}$
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
Return $
\backslash
var{-1}$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
find_best_split
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/find_best_split/class_d_p_tree_ad7f8755be37ad10cf104fba2076dce5e_icgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Call graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename ../visualisation/graphs/find_best_split/call.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Arguments / variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
X, gradients, live_samples
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
params.*, tree_budget, curr_depth
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{DPTree::find
\backslash
_best
\backslash
_split}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxi{red}{0}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function (
\backslash
Comment{size of 
\backslash
texttt{X, gradients}}) {find
\backslash
_best
\backslash
_split(X, gradients, live
\backslash
_samples, curr
\backslash
_depth)}{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{determine node privacy budget}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{green}{7.5}
\end_layout

\begin_layout Plain Layout

    
\backslash
eIf (
\backslash
Comment{
\backslash
texttt{params.use
\backslash
_decay}}){params.use
\backslash
_decay} {  
\end_layout

\begin_layout Plain Layout

		
\backslash
boxitt{green}{3.7}
\end_layout

\begin_layout Plain Layout

		
\backslash
eIf(
\backslash
Comment{
\backslash
texttt{curr
\backslash
_depth == 0}}){curr
\backslash
_depth == 0} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{node
\backslash
_budget} = 
\backslash
frac{
\backslash
var{tree
\backslash
_budget}}{2*({2^{
\backslash
var{max
\backslash
_depth}+1}} + 2^{
\backslash
var{curr
\backslash
_depth}+1})}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	    } {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{node
\backslash
_budget} = 
\backslash
frac{
\backslash
var{tree
\backslash
_budget}}{2*{2^{
\backslash
var{curr
\backslash
_depth}+1}}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

    } {
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{node
\backslash
_budget} = 
\backslash
frac{
\backslash
var{tree
\backslash
_budget}}{2*
\backslash
var{max
\backslash
_depth}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{iterate over all possible splits}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{green}{9.8}
\end_layout

\begin_layout Plain Layout

	
\backslash
For(
\backslash
Comment{number of cols in 
\backslash
texttt{X}}){feature
\backslash
_index 
\backslash
KwInn features} {
\end_layout

\begin_layout Plain Layout

		
\backslash
boxitt{red}{8.5}
\end_layout

\begin_layout Plain Layout

		
\backslash
For(
\backslash
Comment{number of rows in 
\backslash
texttt{X}}){feature
\backslash
_value 
\backslash
KwInn X[feature
\backslash
_index]} {
\end_layout

\begin_layout Plain Layout

			
\backslash
boxittt{red}{1}
\end_layout

\begin_layout Plain Layout

			
\backslash
If (
\backslash
Comment{number of unique feature values}) {
\begin_inset Quotes eld
\end_inset

already encountered feature
\backslash
_value
\begin_inset Quotes erd
\end_inset

} {
\end_layout

\begin_layout Plain Layout

				
\backslash
Continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{gain} = 
\backslash
texttt{
\backslash
emph{compute
\backslash
_gain(X, gradients, live
\backslash
_samples, feature
\backslash
_index, feature
\backslash
_value)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

			
\backslash
boxittt{red}{1}
\end_layout

\begin_layout Plain Layout

			
\backslash
If (
\backslash
Comment{number of splits with no gain}){gain < 0} {
\end_layout

\begin_layout Plain Layout

				
\backslash
Continue
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{gain} = 
\backslash
frac{
\backslash
var{node
\backslash
_budget} * 
\backslash
var{gain}}{2 * 
\backslash
Delta g}$
\backslash
;
\end_layout

\begin_layout Plain Layout

			
\backslash
boxittt{red}{0}
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{candidates}
\backslash
texttt{.insert(Candidate(feature
\backslash
_index, feature
\backslash
_value, gain))}$ 
\backslash
Comment{number of candidates}	
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{choose a split using the exponential mechanism}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{index} = 
\backslash
texttt{
\backslash
emph{exponential
\backslash
_mechanism(candidates)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{construct the node} 
\backslash
boxit{yellow}{0}
\end_layout

\begin_layout Plain Layout

	$
\backslash
texttt{TreeNode *node = new TreeNode(candidates[index])}$ 
\backslash
Comment{internal node vs.
 leaf}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
Return{$
\backslash
texttt{node}$}
\backslash
;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
compute_gain
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/compute_gain/class_d_p_tree_ad7f8755be37ad10cf104fba2076dce5e_icgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Call graph
\begin_inset Newline newline
\end_inset


\begin_inset Graphics
	filename /home/loretanr/ma/code/hardening/visualisation/graphs/compute_gain/class_d_p_tree_ab9426a6ac2e5122e29ecbb6e9c4cd050_cgraph.svg
	scale 55

\end_inset


\end_layout

\begin_layout Paragraph
Arguments / variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
X, gradients, live_samples
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
params.l2_lambda, feature_index, feature_value
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{DPTree::compute
\backslash
_gain}
\end_layout

\begin_layout Plain Layout

  
\backslash
boxi{red}{0}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function (
\backslash
Comment{
\backslash
texttt{X, gradients}}) {compute
\backslash
_gain(X, gradients, live
\backslash
_samples, feature
\backslash
_index, feature
\backslash
_value)}{
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{partition into lhs/rhs}
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{red}{2}
\end_layout

\begin_layout Plain Layout

     $
\backslash
var{lhs}, 
\backslash
var{rhs} = 
\backslash
texttt{
\backslash
emph{samples
\backslash
_l
\backslash
_r
\backslash
_partition(X, live
\backslash
_samples, feature
\backslash
_index, feature
\backslash
_value)}}$ 
\backslash
Comment{lhs/rhs size}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{lhs
\backslash
_size} = 
\backslash
texttt{lhs.size()}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{rhs
\backslash
_size} = 
\backslash
texttt{rhs.size()}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{return on useless split} 
\backslash
boxit{red}{1}
\end_layout

\begin_layout Plain Layout

	
\backslash
If (
\backslash
Comment{useless split}) {lhs
\backslash
_size == 0 
\backslash
KwOr rhs
\backslash
_size == 0} {
\end_layout

\begin_layout Plain Layout

		
\backslash
Return{$
\backslash
texttt{-1}$}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{sums of lhs/rhs gains}  
\backslash
boxit{red}{1}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{lhs
\backslash
_gain} = 
\backslash
texttt{sum(gradients[lhs])}$ 
\backslash
Comment{memory access pattern of left/right gradients}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{rhs
\backslash
_gain} = 
\backslash
texttt{sum(gradients[rhs])}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{lhs
\backslash
_gain} = 
\backslash
frac{
\backslash
var{lhs
\backslash
_gain}^{2}}{
\backslash
var{lhs
\backslash
_size} + 
\backslash
var{params.l2
\backslash
_lambda}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{rhs
\backslash
_gain} = 
\backslash
frac{
\backslash
var{rhs
\backslash
_gain}^{2}}{
\backslash
var{rhs
\backslash
_size} + 
\backslash
var{params.l2
\backslash
_lambda}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

	
\backslash
boxit{yellow}{0}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{total
\backslash
_gain} = 
\backslash
texttt{max(
\backslash
var{lhs
\backslash
_gain} + 
\backslash
var{rhs
\backslash
_gain}, 0)}$ 
\backslash
Comment{
\backslash
texttt{max} might leak whether 
\backslash
texttt{total
\backslash
_gain < 0}}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

	
\backslash
Return{$
\backslash
texttt{total
\backslash
_gain}$}
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
make_leaf_node
\end_layout

\begin_layout Subsubsection

\family typewriter
samples_left_right_partition
\end_layout

\begin_layout Subsubsection

\family typewriter
predict
\end_layout

\begin_layout Section

\family typewriter
class DPEnsemble
\end_layout

\begin_layout Subsection
Methods
\end_layout

\begin_layout Subsubsection

\family typewriter
train
\end_layout

\begin_layout Paragraph
Caller graph
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph
Call graph
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Paragraph
Variables
\end_layout

\begin_layout Itemize
must not leak:
\end_layout

\begin_layout Standard

\family typewriter
TODO
\end_layout

\begin_layout Itemize
can leak:
\end_layout

\begin_layout Standard

\family typewriter
params.*, tree_params.*
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm}
\backslash
setstretch{0.9}
\end_layout

\begin_layout Plain Layout

  
\backslash
caption{DPEnsemble::train}
\end_layout

\begin_layout Plain Layout

  
\backslash
Function {train(dataset)}{
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{compute initial prediction}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{init
\backslash
_score} = 
\backslash
emph{
\backslash
var{compute
\backslash
_init
\backslash
_score(dataset.y)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{each tree gets the full budget since they train on distinct data}
\end_layout

\begin_layout Plain Layout

	$
\backslash
var{tree
\backslash
_privacy
\backslash
_budget} = 
\backslash
texttt{params.privacy
\backslash
_budget}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
tcp{train all trees}
\end_layout

\begin_layout Plain Layout

	
\backslash
For (
\backslash
Comment{bla}) {tree
\backslash
_index = 0 
\backslash
KwTo tree
\backslash
_index = nb
\backslash
_trees - 1} {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{init/update gradients}
\end_layout

\begin_layout Plain Layout

		$
\backslash
emph{
\backslash
var{update
\backslash
_gradients(dataset.gradients, tree
\backslash
_index)}}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{sensitivity for internal nodes}
\end_layout

\begin_layout Plain Layout

		$
\backslash
var{tree
\backslash
_params.
\backslash
ensuremath{
\backslash
Delta g}} = 
\backslash
ensuremath{3*(
\backslash
texttt{params.l2
\backslash
_threshold})^2}$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{sensitivity for leaf nodes}
\end_layout

\begin_layout Plain Layout

		
\backslash
eIf {params.gradient
\backslash
_filtering 
\backslash
KwOr  !params.leaf
\backslash
_clipping} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{tree
\backslash
_params.
\backslash
ensuremath{
\backslash
Delta v}} = 
\backslash
frac{
\backslash
texttt{params.l2
\backslash
_threshold}}{1+
\backslash
texttt{params.l2
\backslash
_lambda}} $
\backslash
;
\end_layout

\begin_layout Plain Layout

		}{
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{tree
\backslash
_params.
\backslash
ensuremath{
\backslash
Delta v}} = 
\backslash
ensuremath{
\backslash
min (
\backslash
frac{
\backslash
texttt{params.l2
\backslash
_threshold}}{1 + 
\backslash
texttt{params.l2
\backslash
_lambda}}, 2* 
\backslash
texttt{params.l2
\backslash
_threshold} * 
\backslash
ensuremath{(1-
\backslash
eta)^{
\backslash
texttt{tree
\backslash
_index}}})}$
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\backslash
tcp{determine number of rows}
\end_layout

\begin_layout Plain Layout

		
\backslash
eIf {params.balance
\backslash
_partition} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{number
\backslash
_of
\backslash
_rows} = 
\backslash
frac{|D|}{
\backslash
texttt{nb
\backslash
_trees}- 
\backslash
texttt{tree
\backslash
_index}} $
\backslash
;
\end_layout

\begin_layout Plain Layout

		} {
\end_layout

\begin_layout Plain Layout

			$
\backslash
var{number
\backslash
_of
\backslash
_rows} = 
\backslash
frac{|D| 
\backslash
eta (1- 
\backslash
eta)^{
\backslash
texttt{tree
\backslash
_index}} } { 1 - (1-
\backslash
eta)^{
\backslash
texttt{nb
\backslash
_trees}} } $
\backslash
;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection

\family typewriter
predict
\end_layout

\begin_layout Subsubsection

\family typewriter
update_gradients
\end_layout

\begin_layout Subsubsection

\family typewriter
add_laplacian_noise
\end_layout

\begin_layout Subsubsection

\family typewriter
remove_rows
\end_layout

\begin_layout Subsubsection

\family typewriter
get_subset
\end_layout

\begin_layout Section
other classes
\end_layout

\end_body
\end_document
